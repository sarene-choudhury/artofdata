---
layout: post
title: API Lab
subtitle: By Sarene
gh-repo: daattali/beautiful-jekyll
gh-badge: [star, fork, follow]
tags: [test]
comments: true
---

## Creating the CSV

This was the most challenging part of the lab for me. I knew the baseline of code I needed to use in creating the csv, but I couldn't figure out how to iterate through all the rows. To solve this, I worked with Divya to set up a loop that would do what we wanted. We originally tried to use a for loop, but then we realized that a while loop was better suited to our needs. Then, we found what we thought should have worked (increasing the variable 'row'), but we were missing information, which turned out to be that we needed to put the code that saved the correct data and printed it, as well as the payload, into the while loop as well because those changed everytime the while loop ran. 

~~~

base_url = "https://hm-cs.herokuapp.com"
endpoint = "/socks"
api_key = "ArtOfDataKEY123"

row = 0

payload = {
    'key': api_key,
    'idx': row
}

response = requests.get(base_url + endpoint, params = payload)
data = response.text
while response.ok:
    payload = {
        'key': api_key,
        'idx': row
    }
    row += 1
    response = requests.get(base_url + endpoint, params = payload)
    data = response.text
    print(data)
if not response.ok:
    print(response.status_code, response.text)
    
~~~

## Starting the analysis

This was the easiest part of the lab, as I already knew how to open the csv and read the information into a variable, 'data', from previous work. The only near challenge in this was deciding which method through which to read the data. I ended up reading it as a list, and then creating two empty lists for the two questions I had to answer. I also initialized variables for the columns from the data that I would need.

~~~

with open("socks.csv", encoding="utf-8-sig") as f:
    data = list(csv.DictReader(f))

    list_of_socks = []
    list_of_colors = []
    
    for sock in data:
        #initializes the variables of sock names and colors
         name = sock["Name"]
        color1 = sock["Color 1"]
        color2 = sock["Color 2"]
    
~~~

## Question 1

To solve this, I knew I needed to figure out an algorithm to find the sock(s) that had the highest occurrence. My first instinct was to hard code a table and then find methods to determine the occurrence of each sock, and then print the ones with the highest occurrence. However, I felt that this would take too long and I wanted to find the most efficient way to code this algorithm. After searching on the internet, I discovered the .mode function that was part of the statistics module, which would find the sock with the highest occurrence once I put the respective data from the previously created variables into a list. However, this only gave me the first sock with the highest occurrence, which was an issue considering that there were multiple such socks. Thankfully, the .multimode function finds all of the highest occuring socks and as such, I was quite efficiently able to solve this question.

~~~

list_of_socks.append(name)
print(statistics.multimode(list_of_socks))

~~~

## Question 2

This question came fairly easily to me, as I had already encountered something like it in previous assignments. As such, I, again, wanted to find the most efficient method to code the algorithm, since I already knew how to solve it otherwise. Instead of using a table, I did some research to find a counting function that would count the occurrence of each value in a list (which I created with the variables of color1 and color2), and I found the .Counter function, which is a part of the collections module. After this, I only needed a way to ensure that there was no double counting. I did so with a simple if statement that would only append color2 to the list of colors that I later used the .Counter function on if it wasn't equal to color1 already.

~~~

list_of_colors.append(color1)
if color1 != color2:
            list_of_colors.append(color2)
print(collections.Counter(list_of_colors))

~~~

## Final Thoughts

I feel quite satisfied with my work on this lab, and though I did face an issue with iterating through rows while converting the API information into a CSV, I thoroughly enjoyed discovering more efficient ways of coding questions that previously took many more unnecessary lines of code. Furthermore, due to the challenge with creating the CSV, it was very much satisfying to finally have the CSV that I had created myself. Overall, this was possibly my favourite work I've done so far this year in Art of Data, and I can tell a definite change in how I approach coding in Python since the beginning of this year, which has positively impacted my approach to problem solving in general. 

